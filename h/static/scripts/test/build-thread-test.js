'use strict';

var buildThread = require('../thread-model');

var SIMPLE_FIXTURE = [{
  id: '1',
  text: 'first annotation',
  references: [],
},{
  id: '2',
  text: 'second annotation',
  references: [],
},{
  id: '3',
  text: 'third annotation',
  references: [1],
}];

/**
 * Filter a Thread, keeping only properties in @p keys for each thread.
 *
 * @param {Thread} thread - Annotation thread generated by buildThread()
 * @param {Array<string>} keys - The keys to retain
 */
function filter(thread, keys) {
  var result = {};
  keys.forEach(function (key) {
    if (key === 'children') {
      result[key] = thread[key].map(function (child) {
        return filter(child, keys);
      });
    } else {
      result[key] = thread[key];
    }
  });
  return result;
}

describe('thread model', function () {

  // TODO
  // - Test threading of new annotations with no ID (only a $$tag)
  // - Test 'collapsed' property is set depending on whether annotation
  //   is in expanded set or not

  describe('threading', function () {
    function createThread(fixture) {
      return filter(buildThread(fixture, {}), ['annotation', 'children']);
    }

    it('arranges parents and children as a thread', function () {
      var thread = createThread(SIMPLE_FIXTURE);
      assert.deepEqual(thread, {
        annotation: undefined,
        children: [{
          annotation: SIMPLE_FIXTURE[0],
          children: [{
            annotation: SIMPLE_FIXTURE[2],
            children: [],
          }],
        },{
          annotation: SIMPLE_FIXTURE[1],
          children: [],
        }],
      });
    });

    it('threads nested replies', function () {
      var NESTED_FIXTURE = [{
        id: '1',
        references: [],
      },{
        id: '2',
        references: ['1'],
      },{
        id: '3',
        references: ['1','2']
      }];

      var thread = createThread(NESTED_FIXTURE);
      assert.deepEqual(thread, {
        annotation: undefined,
        children: [{
            annotation: NESTED_FIXTURE[0],
            children: [{
              annotation: NESTED_FIXTURE[1],
              children: [{
                annotation: NESTED_FIXTURE[2],
                children: [],
              }]
            }]
        }],
      });
    });

    it('handles loops implied by the reply field', function () {
      var LOOPED_FIXTURE = [{
        id: '1',
        references: ['2'],
      },{
        id: '2',
        references: ['1'],
      }];

      var thread = createThread(LOOPED_FIXTURE);
      assert.deepEqual(thread, {
        annotation: undefined,
        children: [{
          annotation: LOOPED_FIXTURE[1],
          children: [{
            annotation: LOOPED_FIXTURE[0],
            children: [],
          }],
        }]
      });
    });

    it('handles missing parent annotations', function () {
      var fixture = [{
        id: '1',
        references: ['3'],
      }];
      var thread = createThread(fixture);
      assert.deepEqual(thread, {
        annotation: undefined,
        children: [{annotation: fixture[0], children: []}],
      });
    });
  });

  describe('filtering', function () {
    // Test filtering by selection, search filter and
    // editing state
    var fixture = [{
      id: '1',
      text: 'first',
      references: [],
    },{
      id: '2',
      text: 'second',
      references: [],
    }];

    it('filters annotations by the search filter', function () {
      var thread = filter(buildThread(fixture, {
        searchFilter: function (annot) {
          return annot.text.match(/first/);
        },
      }), ['annotation', 'children']);
      assert.deepEqual(thread, {
        annotation: undefined,
        children: [{
          annotation: fixture[0],
          children: [],
        }]
      });
    });

    it('filters annotations by the selection filter', function () {
      var thread = filter(buildThread(fixture, {
        selected: ['1'],
      }), ['annotation', 'children']);
      assert.deepEqual(thread, {
        annotation: undefined,
        children: [{annotation: fixture[0], children: []}],
      });
    });

    it('always makes annotations that are being edited visible', function () {
      var thread = filter(buildThread(fixture, {
        selected: ['1'],
        editing: ['2'],
      }), ['annotation', 'children']);
      assert.deepEqual(thread, {
        annotation: undefined,
        children: [{
          annotation: fixture[0],
          children: [],
        },{
          annotation: fixture[1],
          children: [],
        }],
      });
    });
  });

  describe('sort order', function () {
    var fixture = [{
      id: '1',
      updated: 100,
      references: [],
    },{
      id: '2',
      updated: 200,
      references: [],
    }];

    it('sorts top-level annotations using the comparison function', function () {
      var thread = filter(buildThread(fixture, {
        currentSortFn: function (a, b) {
          return a.updated > b.updated;
        },
      }), ['annotation', 'children']);
      assert.deepEqual(thread, {
        annotation: undefined,
        children: [{
          annotation: fixture[1],
          children: [],
        },{
          annotation: fixture[0],
          children: [],
        }]
      });
    });
    // it('does not sort child annotations')
  });

  describe('reply counts', function () {
    it ('populates the reply count field', function () {
      var thread = filter(buildThread(SIMPLE_FIXTURE, {}),
                          ['annotation', 'children', 'replyCount']);
      assert.deepEqual(thread, {
        annotation: undefined,
        children: [{
          annotation: SIMPLE_FIXTURE[0],
          children: [{
            annotation: SIMPLE_FIXTURE[2],
            children: [],
            replyCount: 0,
          }],
          replyCount: 1,
        },{
          annotation: SIMPLE_FIXTURE[1],
          children: [],
          replyCount: 0
        }],
        replyCount: 3,
      });
    });
  });
});
